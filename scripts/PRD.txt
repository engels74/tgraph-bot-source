<context>
# Overview  
TGraph Bot is a Discord bot designed to automatically generate and post Tautulli graphs to a specified Discord channel. It provides insightful visualizations and statistics about your Plex Media Server's activity and performance. The project emphasizes modern Python 3.13 features, a test-driven development approach, comprehensive internationalization support, and robust, non-blocking performance using the `discord.py` library.

The bot solves the problem of manual monitoring and visualization of Plex server statistics by automating the generation of beautiful, informative graphs that are posted directly to Discord channels. This enables server administrators and users to easily track usage patterns, popular content, and server performance without needing to manually access Tautulli dashboards.

# Core Features  
TGraph Bot offers the following key features:

## High-Quality Statistical Graphing
- Automated generation and scheduled posting of Tautulli graphs using **Seaborn** on top of Matplotlib
- Creates clean, modern, and aesthetically pleasing visualizations
- Supports multiple graph types: daily play counts, play counts by day of week/hour, top platforms/users, monthly statistics
- Customizable graph options including colors, grid settings, and annotations

## Discord Integration
- Interactive Discord slash commands: `/about`, `/config`, `/my_stats`, `/update_graphs`, and `/uptime`
- Permission system for command access control
- Built using modern `discord.py` library with async/await patterns
- Automated posting to specified Discord channels

## User-Specific Statistics
- Personal statistics generation via `/my_stats` command
- Direct messaging support for private user data
- Email-based user identification for Plex statistics

## Modern Configuration System
- Robust configuration powered by Pydantic for validation, typing, and default management
- YAML-based configuration with comprehensive options
- Live configuration editing via Discord commands
- Atomic configuration saving with comment preservation

## Internationalization Support
- Full i18n support using gettext-based translation files
- Weblate integration for collaborative translation
- Support for multiple languages (English, Danish, with extensibility for more)

## Resilience and Error Handling
- Proactive handling of API-related issues including Tautulli API downtime
- Discord rate limit handling with graceful fallbacks
- Non-blocking execution using asyncio.to_thread() for CPU-bound operations
- Comprehensive error logging and recovery mechanisms

## Test-Driven Development
- Extensive testing with pytest following TDD methodology
- Type safety verification using basedpyright
- Modern Python 3.13 best practices throughout

# User Experience  
## User Personas
1. **Server Administrator**: Manages Plex server, wants automated monitoring and statistics
2. **Discord Community Members**: Want to see server statistics and their personal usage data
3. **Power Users**: Want detailed customization options and advanced features

## Key User Flows
1. **Initial Setup**: Administrator configures bot with Tautulli API credentials and Discord settings
2. **Automated Posting**: Bot automatically generates and posts graphs based on configured schedule
3. **Manual Updates**: Administrators can trigger immediate graph updates via `/update_graphs` command
4. **Personal Statistics**: Users request personal stats via `/my_stats` command and receive DM with graphs
5. **Configuration Management**: Administrators view and modify settings via `/config` commands

## UI/UX Considerations
- Clean, modern graph aesthetics using Seaborn styling
- Intuitive slash command interface
- Clear error messages and user feedback
- Responsive bot behavior with non-blocking operations
- Customizable visual elements (colors, annotations, grid options)
</context>
<PRD>
# Technical Architecture  

## System Components

### Project Directory Structure
```
.
├── LICENSE
├── README.md
├── pyproject.toml
├── i18n.py
├── main.py
├── .weblate
├── bot/
│   ├── __init__.py
│   ├── commands/
│   │   ├── __init__.py
│   │   ├── about.py
│   │   ├── config.py
│   │   ├── my_stats.py
│   │   ├── update_graphs.py
│   │   └── uptime.py
│   ├── extensions.py
│   ├── permission_checker.py
│   └── update_tracker.py
├── config/
│   ├── __init__.py
│   ├── manager.py
│   ├── config.yml.sample
│   └── schema.py
├── graphs/
│   ├── graph_manager.py
│   ├── user_graph_manager.py
│   └── graph_modules/
│       ├── __init__.py
│       ├── base_graph.py
│       ├── daily_play_count_graph.py
│       ├── data_fetcher.py
│       ├── graph_factory.py
│       ├── play_count_by_dayofweek_graph.py
│       ├── play_count_by_hourofday_graph.py
│       ├── play_count_by_month_graph.py
│       ├── top_10_platforms_graph.py
│       ├── top_10_users_graph.py
│       └── utils.py
├── locale/
│   ├── en/
│   │   └── LC_MESSAGES/
│   │       └── messages.po
│   └── messages.pot
└── utils/
    ├── __init__.py
    └── command_utils.py
```

## File and Directory Descriptions

### Root Directory
- **LICENSE**: Contains the license information for the project (e.g., MIT, GPL)
- **README.md**: Provides an overview of the project, setup instructions, usage examples, and other relevant documentation
- **pyproject.toml**: The standardized project definition file containing metadata, dependencies (discord.py, pydantic, matplotlib, seaborn, httpx), and tool configurations like pytest
- **i18n.py**: Handles internationalization by loading gettext translation files from the locale directory and providing functions to retrieve translated strings
- **main.py**: The main entry point for the bot. Initializes the bot, loads configuration and translations, sets up logging, loads extensions, manages the main event loop, background tasks, and handles overall bot lifecycle and error management
- **.weblate**: Configuration file for Weblate integration, defining project settings, components, and file paths

### bot/ Module
- **bot/__init__.py**: Marks the bot directory as a Python package
- **bot/extensions.py**: Contains utility functions for managing (loading, unloading, reloading) the bot's command extensions (Cogs)
- **bot/permission_checker.py**: Handles checking and logging Discord command permissions for the bot across all guilds, ensuring commands have appropriate access controls
- **bot/update_tracker.py**: Manages the scheduling and tracking of when server-wide graphs should be automatically updated, based on configuration (UPDATE_DAYS, FIXED_UPDATE_TIME)

### bot/commands/ Submodule
- **bot/commands/__init__.py**: Initializes the commands package, importing and making available all command Cogs
- **bot/commands/about.py**: Defines the /about slash command, displaying information about the bot
- **bot/commands/config.py**: Defines the /config slash command group (/config view, /config edit) for viewing and modifying bot configuration settings
- **bot/commands/my_stats.py**: Defines the /my_stats slash command, allowing users to request personal Plex statistics via DM
- **bot/commands/update_graphs.py**: Defines the /update_graphs slash command, allowing administrators to manually trigger graph regeneration
- **bot/commands/uptime.py**: Defines the /uptime slash command, displaying bot uptime since last start

### config/ Module
- **config/__init__.py**: Exposes the main configuration object to the rest of the application
- **config/manager.py**: Core configuration system handling loading config.yml, parsing into Pydantic Settings model, saving changes atomically, and managing live configuration state
- **config/schema.py**: Defines the application's configuration structure using Pydantic BaseModel, serving as source of truth for all settings, types, defaults, and validation rules
- **config/config.yml.sample**: Sample configuration file showing expected structure, keys, and example values

### graphs/ Module
- **graphs/graph_manager.py**: Central orchestrator for server-wide graph generation. Uses GraphFactory to create instances, fetches data via DataFetcher, and runs blocking Matplotlib/Seaborn code in separate threads using asyncio.to_thread() to prevent event loop freezing
- **graphs/user_graph_manager.py**: Handles graph generation for /my_stats command, using asyncio.to_thread() for CPU-bound graph generation to maintain bot responsiveness

### graphs/graph_modules/ Submodule
- **graphs/graph_modules/__init__.py**: Marks the graph_modules directory as a Python package
- **graphs/graph_modules/base_graph.py**: Abstract base class defining common interface for all graph types, using Matplotlib for core figure/axes setup
- **graphs/graph_modules/data_fetcher.py**: Responsible for fetching data from Tautulli API using async-native httpx client, includes robust error handling and caching
- **graphs/graph_modules/graph_factory.py**: Factory class creating instances of specific graph classes based on enabled configuration settings
- **graphs/graph_modules/daily_play_count_graph.py**: Inherits from BaseGraph, uses Seaborn to implement daily play count plotting
- **graphs/graph_modules/play_count_by_dayofweek_graph.py**: Inherits from BaseGraph, uses Seaborn for day-of-week play count visualization
- **graphs/graph_modules/play_count_by_hourofday_graph.py**: Inherits from BaseGraph, uses Seaborn for hourly play count visualization
- **graphs/graph_modules/play_count_by_month_graph.py**: Inherits from BaseGraph, uses Seaborn for monthly play count visualization
- **graphs/graph_modules/top_10_platforms_graph.py**: Inherits from BaseGraph, uses Seaborn for top 10 platforms visualization
- **graphs/graph_modules/top_10_users_graph.py**: Inherits from BaseGraph, uses Seaborn for top 10 users visualization
- **graphs/graph_modules/utils.py**: Contains utility functions for date formatting, folder management, and username censoring

### locale/ Module
- **locale/messages.pot**: Template file containing all translatable strings
- **locale/en/LC_MESSAGES/messages.po**: Contains English translations

### utils/ Module
- **utils/__init__.py**: Marks the utils directory as a Python package
- **utils/command_utils.py**: Contains utility functions for Discord commands, such as formatting output and argument parsing

## Data Models and Configuration Schema

### Configuration Options
The configuration system supports comprehensive settings defined in config/schema.py:

```yaml
# Essential Settings
TAUTULLI_API_KEY: your_tautulli_api_key
TAUTULLI_URL: http://your_tautulli_ip:port/api/v2
DISCORD_TOKEN: your_discord_bot_token
CHANNEL_ID: your_channel_id

# Timing and Retention
UPDATE_DAYS: 7
FIXED_UPDATE_TIME: "XX:XX"  # HH:MM format or "XX:XX" to disable
KEEP_DAYS: 7
TIME_RANGE_DAYS: 30
LANGUAGE: en

# Graph Options
CENSOR_USERNAMES: true
ENABLE_GRAPH_GRID: false
ENABLE_DAILY_PLAY_COUNT: true
ENABLE_PLAY_COUNT_BY_DAYOFWEEK: true
ENABLE_PLAY_COUNT_BY_HOUROFDAY: true
ENABLE_TOP_10_PLATFORMS: true
ENABLE_TOP_10_USERS: true
ENABLE_PLAY_COUNT_BY_MONTH: true

# Graph Colors
TV_COLOR: "#1f77b4"
MOVIE_COLOR: "#ff7f0e"
GRAPH_BACKGROUND_COLOR: "#ffffff"
ANNOTATION_COLOR: "#ff0000"
ANNOTATION_OUTLINE_COLOR: "#000000"
ENABLE_ANNOTATION_OUTLINE: true

# Annotation Options
ANNOTATE_DAILY_PLAY_COUNT: true
ANNOTATE_PLAY_COUNT_BY_DAYOFWEEK: true
ANNOTATE_PLAY_COUNT_BY_HOUROFDAY: true
ANNOTATE_TOP_10_PLATFORMS: true
ANNOTATE_TOP_10_USERS: true
ANNOTATE_PLAY_COUNT_BY_MONTH: true

# Command Cooldown Options
CONFIG_COOLDOWN_MINUTES: 0
CONFIG_GLOBAL_COOLDOWN_SECONDS: 0
UPDATE_GRAPHS_COOLDOWN_MINUTES: 0
UPDATE_GRAPHS_GLOBAL_COOLDOWN_SECONDS: 0
MY_STATS_COOLDOWN_MINUTES: 5
MY_STATS_GLOBAL_COOLDOWN_SECONDS: 60
```

## APIs and Integrations
- **Tautulli API**: RESTful API integration for fetching Plex server statistics
- **Discord API**: Integration via discord.py library for bot functionality
- **Weblate API**: Integration for collaborative translation management

## Infrastructure Requirements
- Python 3.13+ runtime environment
- Dependencies: discord.py, pydantic, matplotlib, seaborn, httpx, pytest
- Access to Tautulli instance with API enabled
- Discord bot token and appropriate permissions
- File system access for configuration, locale files, and temporary graph storage

## Python 3.13 Best Practices Implementation
- **Type Hints and Pydantic**: Every function includes type annotations, Pydantic models ensure data integrity
- **High-Level Libraries**: Seaborn usage for better results with cleaner, more readable code
- **Match Statements**: Streamlined control flow in command processing and data handling
- **Async/Await**: Asynchronous programming with discord.py and httpx for non-blocking I/O
- **Non-Blocking Execution**: CPU-bound tasks delegated to separate threads via asyncio.to_thread()

## Test-Driven Development Architecture
The project follows TDD methodology:
1. **Write tests first**: Tests defined with pytest specify expected behavior
2. **Observe failing tests**: Confirming features not yet implemented
3. **Implement features**: Code written to make tests pass
4. **Refactor**: Code quality improved while maintaining passing tests
5. **Type Safety**: basedpyright verification ensures type correctness

# Development Roadmap  

## Phase 1: Core Infrastructure and Configuration (MVP Foundation)
**Objective**: Establish the foundational systems that all other features depend on

### Core Configuration System
- Implement config/schema.py with Pydantic models for all configuration options
- Create config/manager.py for loading, parsing, and atomic saving of configuration
- Develop config.yml.sample with comprehensive example settings
- Build configuration validation and error handling

### Basic Bot Framework
- Set up main.py as the primary entry point with proper initialization
- Implement bot/extensions.py for command management (loading/unloading Cogs)
- Create basic Discord bot connection and event handling
- Establish logging system and error management framework

### Internationalization Foundation
- Implement i18n.py for gettext-based translation loading
- Set up locale/ directory structure with messages.pot template
- Create initial English translations in locale/en/LC_MESSAGES/
- Establish Weblate integration configuration

**Success Criteria**: Bot can start, load configuration, connect to Discord, and handle basic i18n

## Phase 2: Basic Graph Generation System
**Objective**: Create the core graph generation capabilities without Discord integration

### Graph Module Foundation
- Implement graphs/graph_modules/base_graph.py as abstract base class
- Create graphs/graph_modules/data_fetcher.py with async httpx integration
- Build graphs/graph_modules/graph_factory.py for graph instance creation
- Develop graphs/graph_modules/utils.py with common utility functions

### Individual Graph Implementations
- Implement daily_play_count_graph.py using Seaborn
- Create play_count_by_dayofweek_graph.py with Seaborn styling
- Build play_count_by_hourofday_graph.py for hourly statistics
- Develop remaining graph types (monthly, top platforms, top users)

### Graph Management
- Implement graphs/graph_manager.py with asyncio.to_thread() for non-blocking execution
- Create graphs/user_graph_manager.py for personal statistics
- Build graph generation pipeline with error handling and caching

**Success Criteria**: All graph types can be generated programmatically with proper async handling

## Phase 3: Discord Command Integration
**Objective**: Connect graph generation to Discord commands for user interaction

### Basic Commands
- Implement bot/commands/about.py for bot information display
- Create bot/commands/uptime.py for runtime statistics
- Build bot/permission_checker.py for command access control

### Configuration Commands
- Implement bot/commands/config.py with view and edit subcommands
- Create live configuration editing with validation
- Build configuration display formatting and user feedback

### Graph Commands
- Implement bot/commands/update_graphs.py for manual graph generation
- Create bot/commands/my_stats.py for personal statistics via DM
- Build command cooldown system and rate limiting

**Success Criteria**: All Discord commands functional with proper permission handling

## Phase 4: Automated Scheduling and Advanced Features
**Objective**: Add automated posting and advanced functionality

### Automated Posting System
- Implement bot/update_tracker.py for scheduled graph updates
- Create background task management for automatic posting
- Build flexible scheduling with UPDATE_DAYS and FIXED_UPDATE_TIME support

### Advanced Graph Features
- Implement comprehensive customization options (colors, annotations, grid)
- Create username censoring functionality
- Build advanced graph styling and formatting options

### Utility Systems
- Implement utils/command_utils.py for Discord command utilities
- Create comprehensive error handling and recovery mechanisms
- Build performance optimization and caching systems

**Success Criteria**: Bot operates autonomously with scheduled posting and full feature set

## Phase 5: Polish and Production Readiness
**Objective**: Finalize the system for production deployment

### Testing and Quality Assurance
- Comprehensive pytest test suite covering all modules
- Type safety verification with basedpyright
- Integration testing for Discord and Tautulli APIs
- Performance testing and optimization

### Documentation and Deployment
- Complete README.md with setup and usage instructions
- Finalize configuration documentation
- Create deployment guides and troubleshooting documentation
- Package management and distribution preparation

### Internationalization Completion
- Complete translation support for all user-facing strings
- Weblate integration testing and workflow establishment
- Multi-language testing and validation

**Success Criteria**: Production-ready bot with comprehensive documentation and testing

# Logical Dependency Chain

## Foundation Layer (Must be built first)
1. **Configuration System** (config/schema.py, config/manager.py)
   - All other components depend on configuration
   - Provides type-safe settings management
   - Enables runtime configuration changes

2. **Internationalization Framework** (i18n.py, locale structure)
   - Required for all user-facing text
   - Must be established before implementing commands
   - Enables multi-language support from the start

3. **Basic Bot Framework** (main.py, bot/extensions.py)
   - Provides Discord connection and command loading infrastructure
   - Required for all Discord functionality
   - Establishes error handling and logging patterns

## Core Functionality Layer (Build upon foundation)
4. **Graph Generation System** (graphs/graph_modules/)
   - Independent of Discord integration initially
   - Can be developed and tested separately
   - Provides the core value proposition of the bot

5. **Data Fetching** (graphs/graph_modules/data_fetcher.py)
   - Required for all graph generation
   - Handles Tautulli API integration
   - Provides caching and error handling for external dependencies

## Integration Layer (Connects core functionality to user interface)
6. **Graph Managers** (graphs/graph_manager.py, graphs/user_graph_manager.py)
   - Orchestrates graph generation with async handling
   - Bridges graph modules with Discord integration
   - Implements non-blocking execution patterns

7. **Discord Commands** (bot/commands/)
   - Provides user interface to core functionality
   - Can be implemented incrementally (start with basic commands)
   - Each command can be developed and tested independently

## Advanced Features Layer (Enhances core functionality)
8. **Automated Scheduling** (bot/update_tracker.py)
   - Builds upon graph managers and Discord integration
   - Provides autonomous operation capability
   - Can be added after manual commands are working

9. **Permission and Utility Systems** (bot/permission_checker.py, utils/)
   - Enhances security and user experience
   - Can be added incrementally as needed
   - Provides polish and production readiness

## Getting to Usable Frontend Quickly
The fastest path to a working, visible frontend:
1. Basic bot connection (main.py minimal implementation)
2. Simple /about command (demonstrates Discord integration)
3. Basic graph generation (one graph type working)
4. /update_graphs command (demonstrates core functionality)

This approach provides a working demonstration within the first few development cycles while establishing the foundation for all advanced features.

# Risks and Mitigations  

## Technical Challenges

### Risk: Discord API Rate Limiting
**Impact**: Bot commands may fail or be delayed during high usage
**Mitigation**: 
- Implement proper rate limiting in discord.py integration
- Add command cooldowns via configuration
- Build graceful fallback mechanisms for rate limit scenarios
- Use asyncio.to_thread() to prevent blocking during graph generation

### Risk: Tautulli API Downtime or Connectivity Issues
**Impact**: Graph generation fails, no data available for visualization
**Mitigation**:
- Implement robust error handling in data_fetcher.py
- Add retry mechanisms with exponential backoff
- Cache previous data for fallback scenarios
- Provide clear error messages to users when API is unavailable

### Risk: CPU-Intensive Graph Generation Blocking Bot
**Impact**: Bot becomes unresponsive during graph creation, Discord commands timeout
**Mitigation**:
- Use asyncio.to_thread() for all matplotlib/seaborn operations
- Implement proper async patterns throughout graph generation pipeline
- Add progress indicators for long-running operations
- Optimize graph generation algorithms for performance

### Risk: Memory Usage from Graph Generation
**Impact**: Bot memory consumption grows over time, potential crashes
**Mitigation**:
- Implement proper cleanup of matplotlib figures and resources
- Add configurable image retention policies (KEEP_DAYS)
- Monitor memory usage and implement garbage collection strategies
- Use streaming approaches for large datasets

## MVP Definition and Scope Management

### Risk: Feature Creep and Scope Expansion
**Impact**: Development timeline extends indefinitely, core functionality delayed
**Mitigation**:
- Clearly define MVP as: basic bot connection + one graph type + manual update command
- Implement feature flags for advanced functionality
- Use configuration-driven feature enabling
- Maintain strict separation between core and advanced features

### Risk: Over-Engineering Initial Implementation
**Impact**: Delayed delivery of working functionality, complexity without benefit
**Mitigation**:
- Start with simplest possible implementations
- Use TDD to drive minimal feature implementation
- Refactor only after tests pass and functionality is proven
- Prioritize working code over perfect architecture initially

### Risk: Inadequate Testing Strategy
**Impact**: Bugs in production, difficult maintenance, regression issues
**Mitigation**:
- Implement TDD from the beginning with pytest
- Use basedpyright for type safety verification
- Create integration tests for Discord and Tautulli APIs
- Establish CI/CD pipeline for automated testing

## Resource and Dependency Constraints

### Risk: External Service Dependencies
**Impact**: Bot functionality depends on external services (Discord, Tautulli)
**Mitigation**:
- Design for graceful degradation when services unavailable
- Implement comprehensive error handling and user feedback
- Create offline testing capabilities with mocked services
- Document service requirements and setup procedures

### Risk: Python 3.13 Compatibility Issues
**Impact**: Dependencies may not support latest Python version
**Mitigation**:
- Verify all dependencies support Python 3.13 before implementation
- Have fallback plans for alternative libraries if needed
- Use virtual environments for dependency isolation
- Maintain compatibility testing across Python versions

### Risk: Discord Bot Permission Complexity
**Impact**: Bot may not function properly due to insufficient permissions
**Mitigation**:
- Implement comprehensive permission checking (bot/permission_checker.py)
- Provide clear documentation for required Discord permissions
- Build permission validation into bot startup process
- Create troubleshooting guides for permission issues

### Risk: Configuration Complexity
**Impact**: Users struggle with setup, leading to support burden
**Mitigation**:
- Provide comprehensive config.yml.sample with examples
- Implement validation with clear error messages
- Create setup documentation with step-by-step instructions
- Build configuration validation tools and helpers

# Appendix  

## Research Findings

### Discord Bot Best Practices
- Use discord.py 2.x for modern async/await patterns
- Implement proper command cooldowns to prevent abuse
- Use slash commands for better user experience
- Handle rate limiting gracefully with built-in discord.py features

### Graph Generation Performance
- Seaborn provides superior aesthetics with minimal code complexity
- matplotlib figure cleanup is critical for memory management
- asyncio.to_thread() is the recommended approach for CPU-bound operations in async contexts
- PNG format provides best balance of quality and file size for Discord

### Internationalization Standards
- GNU gettext is the industry standard for Python i18n
- Weblate provides excellent collaborative translation workflows
- String extraction should be automated in CI/CD pipeline
- Context information improves translation quality

## Technical Specifications

### Minimum System Requirements
- Python 3.13+
- 512MB RAM (recommended 1GB for graph generation)
- 100MB disk space for installation
- Network connectivity to Discord and Tautulli APIs

### Performance Targets
- Graph generation: <30 seconds per graph type
- Command response time: <5 seconds for non-graph commands
- Memory usage: <200MB baseline, <500MB during graph generation
- Uptime: 99%+ availability with proper error handling

### Security Considerations
- API keys stored in configuration files (not in code)
- Discord token protection and rotation capabilities
- Input validation for all user-provided data
- Rate limiting to prevent abuse

### Scalability Considerations
- Single-server deployment initially
- Stateless design enables horizontal scaling if needed
- Database-free architecture reduces complexity
- Configuration-driven feature enabling supports gradual rollout

## Development Standards

### Code Quality Requirements
- 100% type annotation coverage
- basedpyright type checking with zero errors
- pytest test coverage >90%
- PEP 8 compliance with automated formatting

### Testing Strategy
- Unit tests for all individual modules
- Integration tests for Discord and Tautulli APIs
- End-to-end tests for complete user workflows
- Performance tests for graph generation

### Documentation Requirements
- Comprehensive README with setup instructions
- API documentation for all public interfaces
- Configuration reference with examples
- Troubleshooting guides for common issues
